# 决策日志

| 日期       | 决策                   | 理由                                                          |
| ---------- | ---------------------- | ------------------------------------------------------------- |
| 2025-06-23 | 初始化项目 Memory Bank | 为了更好地管理项目知识、跟踪进度和记录决策。                  |
| 2025-06-23 | 确定项目类型为 Golang  | 基于项目文件结构（`go.mod`, `cmd/app/main.go`）进行自动识别。 |

| 2025-06-23 | 采纳“流式工具调用”模式 | 经过对比分析，为了追求极致的用户交互体验，减少用户等待焦虑，决定采纳此高级模式。 |

---

### 代码实现 [LLM Agent Streaming Refactor]

[2025-06-24 13:21:00] - 成功重构了 LLM Agent 的流式处理逻辑，以解决 JSON 分块问题。

**实现细节：**

-   创建了 `createStreamingProcessor` 辅助函数，它返回一个闭包来处理流式块。
-   该处理器使用 `json.Decoder` 和一个内部 `bytes.Buffer` 来稳健地解析流中的 JSON 对象碎片。
-   它能够正确处理纯文本内容、完整的 JSON 对象以及被分割的 JSON 对象。
-   重构了 `StartChatCLI` 和 `HandleToolCallAndRespond`，使用新的处理器来提供流畅的“打字机”效果。
-   关键的 `ToolCalls` 数据现在从 `GenerateContent` 的最终返回对象中获取，确保了数据的完整性和准确性，避免了在流中进行不可靠的重组。

**测试框架：**

-   使用了 Go 语言内置的 `testing` 包。
-   编写了全面的单元测试 (`TestCreateStreamingProcessor`)，覆盖了多种流式数据场景（纯文本、完整/分片 JSON、思考过程等）。

**测试结果：**

-   覆盖率：100% (由测试用例生成器确认)
-   通过率：100% (由测试用例生成器确认)

---

### 代码实现 [LLM 工具重构]

[2025-06-25 14:09:35] - 重构 `internal/llm/tools.go` 以增强工具定义并改进错误处理。

**实现细节：**

-   **`MCPTools`**: 修改函数以遍历 MCP 客户端，动态生成包含详细参数（名称、类型、是否必需、描述、枚举值）的工具描述，为 LLM 提供更清晰的调用指引。
-   **`ExecuteMCPTool`**: 重写错误处理逻辑。当工具调用返回`IsError: true`时，会解析结构化的错误内容，并将其格式化为对人类和模型都友好的纯文本错误消息，避免了向 LLM 直接返回 JSON。
-   **辅助函数**: 添加了`formatToolParameters`和`formatMCPError`两个辅助函数来分别处理工具参数的格式化和错误信息的解析。

**测试框架：**

-   使用 Go 语言内置的`testing`包。
-   使用`testify/assert`和`testify/require`进行断言。
-   通过模拟`service.McpClient`接口来隔离对外部服务的依赖。

**测试结果：**

-   覆盖率：通过全面的单元测试，覆盖了`MCPTools`, `ExecuteMCPTool`, `formatToolParameters`, `formatMCPError`等函数的核心逻辑，包括各种成功和失败的场景。
-   通过率：100%

---

### 决策

[2025-07-01 16:27:21] - 设计并采纳“交互式中断循环”机制

**理由:** 当前的“单向流式工具调用”模式无法在 AI 需要信息时暂停等待用户输入，导致无效的执行循环和糟糕的用户体验。

**解决方案:**

1.  **定义信令:** 引入一个特殊的工具调用 `ask_user_for_input` 作为中断信令。
2.  **修改流程:** 客户端在处理 LLM 流时，若检测到此信令，则立即暂停执行、清空待处理的工具调用、向用户展示问题并等待输入。
3.  **恢复循环:** 用户的回答将被作为新消息加入对话历史，并重新启动 LLM 的思考流程。

**影响:**

-   **优点:** 根本上解决了交互死循环问题，实现了真正的“人机协作”。
-   **缺点:** 增加了客户端逻辑的复杂度，需要在 `stream-handler.go` 和 `agent.go` 中进行修改。
